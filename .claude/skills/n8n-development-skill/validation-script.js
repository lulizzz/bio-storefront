#!/usr/bin/env node

/**
 * n8n Workflow Validation Script
 *
 * This utility script validates n8n workflow JSON to catch common errors.
 * Use it to verify workflows generated by Claude before importing to n8n.
 *
 * Usage:
 *   node validation-script.js workflow.json
 */

const fs = require('fs');

function validateWorkflow(jsonPath) {
  console.log(`\nüîç Validating n8n workflow: ${jsonPath}\n`);

  let errors = [];
  let warnings = [];
  let workflow;

  // Parse JSON
  try {
    const content = fs.readFileSync(jsonPath, 'utf8');
    workflow = JSON.parse(content);
    console.log('‚úÖ Valid JSON structure');
  } catch (error) {
    console.error('‚ùå Invalid JSON:', error.message);
    process.exit(1);
  }

  // Check required top-level keys
  const requiredKeys = ['name', 'nodes', 'connections', 'settings'];
  requiredKeys.forEach(key => {
    if (!workflow[key]) {
      errors.push(`Missing required key: "${key}"`);
    }
  });

  if (!workflow.nodes || !Array.isArray(workflow.nodes)) {
    errors.push('Nodes must be an array');
  } else {
    console.log(`‚úÖ Found ${workflow.nodes.length} nodes`);

    // Validate each node
    const nodeIds = new Set();
    workflow.nodes.forEach((node, index) => {
      const nodePrefix = `Node ${index + 1} (${node.name || 'unnamed'})`;

      // Required node fields
      if (!node.id) {
        errors.push(`${nodePrefix}: Missing "id"`);
      } else {
        // Check for duplicate IDs
        if (nodeIds.has(node.id)) {
          errors.push(`${nodePrefix}: Duplicate ID "${node.id}"`);
        }
        nodeIds.add(node.id);

        // Validate UUID format
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(node.id)) {
          warnings.push(`${nodePrefix}: ID is not a valid UUID v4`);
        }
      }

      if (!node.name) {
        errors.push(`${nodePrefix}: Missing "name"`);
      }

      if (!node.type) {
        errors.push(`${nodePrefix}: Missing "type"`);
      }

      if (!node.position || !Array.isArray(node.position) || node.position.length !== 2) {
        errors.push(`${nodePrefix}: Invalid "position" - must be [x, y] array`);
      }

      if (!node.typeVersion) {
        warnings.push(`${nodePrefix}: Missing "typeVersion"`);
      }

      // Check for critical "options": {} in parameters
      if (node.parameters && typeof node.parameters === 'object') {
        if (!node.parameters.hasOwnProperty('options')) {
          warnings.push(`${nodePrefix}: Missing "options": {} in parameters (may cause errors)`);
        }
      }

      // Check for OpenAI endpoint mistakes
      if (node.type === 'n8n-nodes-base.httpRequest' && node.parameters) {
        const url = node.parameters.url;
        if (url && typeof url === 'string') {
          if (url.includes('/v1/completions') || url.includes('/v1/chat/completions')) {
            errors.push(`${nodePrefix}: Uses outdated OpenAI endpoint. Use "/v1/responses" instead`);
          }
        }
      }
    });
  }

  // Validate connections
  if (workflow.connections && typeof workflow.connections === 'object') {
    const nodeIds = new Set(workflow.nodes.map(n => n.id));
    const nodeNames = new Set(workflow.nodes.map(n => n.name));

    Object.entries(workflow.connections).forEach(([sourceId, connections]) => {
      // Check if source exists (can be ID or name)
      if (!nodeIds.has(sourceId) && !nodeNames.has(sourceId)) {
        errors.push(`Connection from unknown node: "${sourceId}"`);
      }

      // Validate connection structure
      if (connections.main && Array.isArray(connections.main)) {
        connections.main.forEach((outputConnections, outputIndex) => {
          if (Array.isArray(outputConnections)) {
            outputConnections.forEach((conn, connIndex) => {
              if (!conn.node) {
                errors.push(`Connection from "${sourceId}" output ${outputIndex} missing "node"`);
              } else if (!nodeIds.has(conn.node) && !nodeNames.has(conn.node)) {
                errors.push(`Connection to unknown node: "${conn.node}"`);
              }
            });
          }
        });
      }
    });
    console.log(`‚úÖ Connections validated`);
  }

  // Check settings
  if (workflow.settings) {
    if (!workflow.settings.executionOrder) {
      warnings.push('Missing "executionOrder" in settings (recommended: "v1")');
    }
    console.log(`‚úÖ Settings present`);
  }

  // Report results
  console.log('\n' + '='.repeat(60));

  if (errors.length === 0 && warnings.length === 0) {
    console.log('\n‚ú® Validation passed! No errors or warnings.\n');
    console.log('This workflow should be ready to import to n8n.');
  } else {
    if (errors.length > 0) {
      console.log('\n‚ùå ERRORS (must fix):');
      errors.forEach(err => console.log(`   - ${err}`));
    }

    if (warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  WARNINGS (recommended to fix):');
      warnings.forEach(warn => console.log(`   - ${warn}`));
    }

    console.log('');
    if (errors.length > 0) {
      console.log('‚ùå Validation failed. Please fix errors before importing.');
      process.exit(1);
    } else {
      console.log('‚ö†Ô∏è  Validation passed with warnings. Workflow may work but improvements suggested.');
    }
  }

  console.log('='.repeat(60) + '\n');
}

// CLI execution
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage: node validation-script.js <workflow.json>');
    console.log('\nValidates n8n workflow JSON for common errors.');
    process.exit(1);
  }

  const workflowPath = args[0];

  if (!fs.existsSync(workflowPath)) {
    console.error(`Error: File not found: ${workflowPath}`);
    process.exit(1);
  }

  validateWorkflow(workflowPath);
}

module.exports = { validateWorkflow };
